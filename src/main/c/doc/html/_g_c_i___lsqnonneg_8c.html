<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>SLIM Curve: GCI_Lsqnonneg.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">SLIM Curve
   &#160;<span id="projectnumber">1</span>
   </div>
   <div id="projectbrief">SLIM-curve package for exponential curve fitting of spectral lifetime data.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">GCI_Lsqnonneg.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>SLIM Curve - Non-negative Least Squares.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdio.h&gt;</code><br/>
<code>#include &lt;stdlib.h&gt;</code><br/>
<code>#include &lt;string.h&gt;</code><br/>
<code>#include &lt;math.h&gt;</code><br/>
<code>#include &quot;<a class="el" href="_g_c_i___lsqnonneg_8h_source.html">GCI_Lsqnonneg.h</a>&quot;</code><br/>
</div>
<p><a href="_g_c_i___lsqnonneg_8c_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:affe776513b24d84b39af8ab0930fef7f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="affe776513b24d84b39af8ab0930fef7f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>max</b>(a, b)&#160;&#160;&#160;((a)&lt;(b) ? (b) : (a))</td></tr>
<tr class="separator:affe776513b24d84b39af8ab0930fef7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c707deff4e68c7283f2ed73665e0c77"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_g_c_i___lsqnonneg_8c.html#a5c707deff4e68c7283f2ed73665e0c77">MAX_VARS</a>&#160;&#160;&#160;50</td></tr>
<tr class="memdesc:a5c707deff4e68c7283f2ed73665e0c77"><td class="mdescLeft">&#160;</td><td class="mdescRight">The greatest number of variables to be determined.  <a href="#a5c707deff4e68c7283f2ed73665e0c77">More...</a><br/></td></tr>
<tr class="separator:a5c707deff4e68c7283f2ed73665e0c77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be9be2628a7cde262d0ad7c4ebf9339"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_g_c_i___lsqnonneg_8c.html#a8be9be2628a7cde262d0ad7c4ebf9339">MAX_EQNS</a>&#160;&#160;&#160;10000</td></tr>
<tr class="memdesc:a8be9be2628a7cde262d0ad7c4ebf9339"><td class="mdescLeft">&#160;</td><td class="mdescRight">The greatest number of equations to be used.  <a href="#a8be9be2628a7cde262d0ad7c4ebf9339">More...</a><br/></td></tr>
<tr class="separator:a8be9be2628a7cde262d0ad7c4ebf9339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ebf6899d6c1c8b7b9d09be872c05aae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ebf6899d6c1c8b7b9d09be872c05aae"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_g_c_i___lsqnonneg_8c.html#a6ebf6899d6c1c8b7b9d09be872c05aae">EPS</a>&#160;&#160;&#160;1e-9</td></tr>
<tr class="memdesc:a6ebf6899d6c1c8b7b9d09be872c05aae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate machine epsilon. <br/></td></tr>
<tr class="separator:a6ebf6899d6c1c8b7b9d09be872c05aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a156b862ebf6d213f5da19b9e3ccb779e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a156b862ebf6d213f5da19b9e3ccb779e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_g_c_i___lsqnonneg_8c.html#a156b862ebf6d213f5da19b9e3ccb779e">TOL</a>&#160;&#160;&#160;(100*<a class="el" href="_g_c_i___lsqnonneg_8c.html#a6ebf6899d6c1c8b7b9d09be872c05aae">EPS</a>)</td></tr>
<tr class="memdesc:a156b862ebf6d213f5da19b9e3ccb779e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tolerance. <br/></td></tr>
<tr class="separator:a156b862ebf6d213f5da19b9e3ccb779e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a581f9a5f6455213315a5e37ff197f44e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a581f9a5f6455213315a5e37ff197f44e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>Amatrix</b>(row, col)&#160;&#160;&#160;A[col][row]</td></tr>
<tr class="separator:a581f9a5f6455213315a5e37ff197f44e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9dc0b48ff8ccb3ab5bfcd48e73fd1aa9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_g_c_i___lsqnonneg_8c.html#a9dc0b48ff8ccb3ab5bfcd48e73fd1aa9">Householder</a> (int mode, double *v, int p, int l, int m, double *u_p, double *C[], int nC)</td></tr>
<tr class="memdesc:a9dc0b48ff8ccb3ab5bfcd48e73fd1aa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function Householder.  <a href="#a9dc0b48ff8ccb3ab5bfcd48e73fd1aa9">More...</a><br/></td></tr>
<tr class="separator:a9dc0b48ff8ccb3ab5bfcd48e73fd1aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae80324df1fc131ce0f8b87965b68af30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_g_c_i___lsqnonneg_8c.html#ae80324df1fc131ce0f8b87965b68af30">GivensCalc</a> (double v_1, double v_2, double *c, double *s, double *r)</td></tr>
<tr class="memdesc:ae80324df1fc131ce0f8b87965b68af30"><td class="mdescLeft">&#160;</td><td class="mdescRight">GivensCalc.  <a href="#ae80324df1fc131ce0f8b87965b68af30">More...</a><br/></td></tr>
<tr class="separator:ae80324df1fc131ce0f8b87965b68af30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f057044890214807647841dfeddc11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_g_c_i___lsqnonneg_8c.html#a26f057044890214807647841dfeddc11">GivensApply</a> (double c, double s, double *z_1, double *z_2)</td></tr>
<tr class="memdesc:a26f057044890214807647841dfeddc11"><td class="mdescLeft">&#160;</td><td class="mdescRight">GivensApply.  <a href="#a26f057044890214807647841dfeddc11">More...</a><br/></td></tr>
<tr class="separator:a26f057044890214807647841dfeddc11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b6201eeb7a64bbb4070606e087503a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_g_c_i___lsqnonneg_8c.html#aa4b6201eeb7a64bbb4070606e087503a">GCI_lsqnonneg</a> (double **A_orig, double *b_orig, double *x, int m, int n, int preserve, double *rnorm_orig, double *lambda)</td></tr>
<tr class="memdesc:aa4b6201eeb7a64bbb4070606e087503a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function GCI_lsqnonneg.  <a href="#aa4b6201eeb7a64bbb4070606e087503a">More...</a><br/></td></tr>
<tr class="separator:aa4b6201eeb7a64bbb4070606e087503a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>SLIM Curve - Non-negative Least Squares. </p>
<p>Non-neg least squares library function</p>
<p>This code is based on code and descriptions in the book Lawson, C.L. and Hanson, R.J., Solving Least Squares Problems, Prentice-Hall, 1974</p>
<p>A brief description of the various algorithms used is included within this file, but for a full explanation, please refer to the above-mentioned book or a similar reference.</p>
<p>Julian Gilbey, Gray Cancer Institute, September 2002 </p>

<p>Definition in file <a class="el" href="_g_c_i___lsqnonneg_8c_source.html">GCI_Lsqnonneg.c</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a8be9be2628a7cde262d0ad7c4ebf9339"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_EQNS&#160;&#160;&#160;10000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The greatest number of equations to be used. </p>
<p>Again, this is to allocate an array in advance </p>

<p>Definition at line <a class="el" href="_g_c_i___lsqnonneg_8c_source.html#l00061">61</a> of file <a class="el" href="_g_c_i___lsqnonneg_8c_source.html">GCI_Lsqnonneg.c</a>.</p>

</div>
</div>
<a class="anchor" id="a5c707deff4e68c7283f2ed73665e0c77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_VARS&#160;&#160;&#160;50</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The greatest number of variables to be determined. </p>
<p>This is to allocate an array in advance to save having to use malloc/free </p>

<p>Definition at line <a class="el" href="_g_c_i___lsqnonneg_8c_source.html#l00057">57</a> of file <a class="el" href="_g_c_i___lsqnonneg_8c_source.html">GCI_Lsqnonneg.c</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="aa4b6201eeb7a64bbb4070606e087503a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GCI_lsqnonneg </td>
          <td>(</td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>A_orig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b_orig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>preserve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>rnorm_orig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function GCI_lsqnonneg. </p>
<p>This function solves the non-negative least squares problem.</p>
<p>This function solves the non-negative least squares problem: minimise |Ax-b| subject to x &gt;= 0 (where |v| is the 2-norm of the vector v).</p>
<p>Arguments: A, an m x n matrix, in the form double A[n][m], so the columns of A are A[0], A[1], ..., A[n-1] b, the m-vector</p>
<p>!!! NB: A and B will both be modified unless preserve is !!! non-zero (see below).</p>
<p>x, the solution will be placed here m ) the dimensions of A n ) preserve, copy A and b before solving the problem rnorm, (double *) the value of |Ax-b| with the determined x if the function was successful or if the iteration count was exceeded. This can be NULL. lambda, an n-vector which will contain the dual vector on completion (that is, the Lagrange multipliers). This can be NULL.</p>
<p>On exit: The return value will be 0 on success, and negative if a problem occurred: -1: m &gt; MAX_EQNS or m &lt;= 0 -2: n &gt; MAX_VARS or n &lt;= 0 -3: iteration count exceeded: more than 3*n iterations performed -4: memory allocation problems</p>
<p>The algorithm is similar to the simplex algorithm, and uses Lagrange multipliers.</p>
<p>1 Set P:={}, Z:={1,2,...,n}, x:=0 2 Compute w := A^T (b-Ax) 3 If Z={} or if w_j &lt;= 0 for all j in Z, stop 4 Find t in Z such that w_t = max { w_j : j in Z } 5 Move index t from Z to P 6 Let A_P denote the m x n matrix defined by </p>
<pre class="fragment">                   ( column j of A   if j in P
 column j of A_P := (
                   ( 0               if j in Z
</pre><p>Compute the n-vector z as a solution of the regular least squares problem minimise | A_P z - b |. Note that only the components z_j, j in P, are determined by this problem. Define z_j:=0 for j in Z. 7 If z_j&gt;0 for all j in P, then set x:=z and goto step 2 8 Find an index q in P such that x_q/(x_q-z_q) = min { x_j/(x_j-z_j) : z_j &lt;= 0, j in P } 9 Set alpha := x_q/(x_q-z_q) 10 Set x := x + alpha(z-x) 11 Move from set P to set Z all j in P for which x_j=0. Go to step 6.</p>
<p>On termination, x satisfies x_j&gt;0 for j in P and x_j=0 for j in Z, and x is a solution to the least squares problem minimise |A_P z - b|.</p>
<p>Step 6 (finding the solution to the least squares problem |A_P z - b|) is performed using a QR factorisation of A_P, which in turn is calculated using Householder matrices and Givens rotations, and clever tricks for keeping track of the QR factorisation of A_P as P changes, as we describe below. </p>

<p>Definition at line <a class="el" href="_g_c_i___lsqnonneg_8c_source.html#l00388">388</a> of file <a class="el" href="_g_c_i___lsqnonneg_8c_source.html">GCI_Lsqnonneg.c</a>.</p>

</div>
</div>
<a class="anchor" id="a26f057044890214807647841dfeddc11"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GivensApply </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>z_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>z_2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GivensApply. </p>
<p>The function GivensApply applies a Givens rotation to a 2-vector. No rocket science there.</p>
<p>Here, then, are the algorithms we use:</p>
<p>Calculate a Givens rotation for the vector (v_1 v_2)^T (GivensCalc):</p>
<p>Arguments: v_1, v_2, the input vector c, s, r, pointers to the answers. r may point to v_1 or v_2</p>
<p>1 if |v_1| &lt;= |v_2| go to step 8 2 w := v_2/v_1 3 q := sqrt(1+w^2) 4 c := 1/q 5 if v_1 &lt; 0, c := -c 6 s := wc 7 r := |v_1|.q and stop 8 if v_2 != 0, go to step 10 9 [v_1=v_2=0] c := 1, s:= 0, r := 0, stop 10 w := v_1/v_2 11 q := sqrt(1+w^2) 12 s := 1/q 13 if v_1 &lt; 0, s := -s 14 c := ws 15 r := |v_2|.q and stop</p>
<p>Apply the Givens rotation G to the vector (z_1 z_2)^T (GivensApply):</p>
<p>Arguments: c, s, components of the Givens rotation matrix z_1, z_2, (double *) the vector to apply it to; these will be overwritten!</p>
<p>1 w := z_1.c + z_2.s 2 z_2 := -z_1.s + z_2.c 3 z_1 := w </p>

<p>Definition at line <a class="el" href="_g_c_i___lsqnonneg_8c_source.html#l00309">309</a> of file <a class="el" href="_g_c_i___lsqnonneg_8c_source.html">GCI_Lsqnonneg.c</a>.</p>

</div>
</div>
<a class="anchor" id="ae80324df1fc131ce0f8b87965b68af30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GivensCalc </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GivensCalc. </p>
<p>The GivensCalc function takes as input a 2-vector, and computes the Givens rotation for this vector.</p>
<p>If the vector is v = (v_1 v_2)^T != 0, then the Givens rotation is the 2x2 (special) orthogonal matrix </p>
<pre class="fragment">         G = (  c  s )
             ( -s  c )
</pre><p>(with c^2 + s^2 = 1) such that Gv = (r 0)^T, where r=|v|=sqrt(v_1^2 + v_2^2).</p>
<p>This function calculates c, s and r, avoiding overflow and underflow issues, and returns these values. (We can allow r to overwrite v_1 or v_2 if we wish.) The calculation is as follows:</p>
<p>To compute r=sqrt(x^2 + y^2): t := max {|x|, |y|} u := min {|x|, |y|} r := ( t.sqrt(1+(u/t)^2) if t != 0 ( 0 if t = 0 </p>

<p>Definition at line <a class="el" href="_g_c_i___lsqnonneg_8c_source.html#l00241">241</a> of file <a class="el" href="_g_c_i___lsqnonneg_8c_source.html">GCI_Lsqnonneg.c</a>.</p>

</div>
</div>
<a class="anchor" id="a9dc0b48ff8ccb3ab5bfcd48e73fd1aa9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Householder </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>u_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>C</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function Householder. </p>
<p>This function takes as input a vector, a pivot element and a zero point, and applies a Householder transformation to the vector to make all of its entries zero from the point specified, pivoting around the specified pivot entry, modifying the vector in the process, as described below. This function can also take a collection of other vectors and apply this Householder transformation to these vectors.</p>
<p>Here is a brief description of Householder transformations: we are looking for an orthogonal transformation Q with</p>
<p>Qv = ( v_0 v_1 ... v_{p-1} -sigma.sqrt(v_p^2+sum_{i=l}^{m-1} v_i^2) v_{p+1} ... v_{l-1} 0 ... 0)^T =: y</p>
<p>where sigma = +1 if v_p &gt;= 0 and -1 if v_p &lt; 0.</p>
<p>Here p is the pivot index and l is the zeroing index, where we assume 0 &lt;= p &lt;= l &lt; m (where v is an m-vector, zero-based). If these assumptions are not true, we take Q=I.</p>
<p>Q is given by Q = I - 2uu^T/|u|^2 for some vector u, but we do not actually need to calculate it. We do the following:</p>
<p>Compute: s := -sigma.sqrt(v_p^2+sum_{i=l}^m v_i^2) u_i := 0, i=0, ..., p-1 u_p := v_p - s u_i := 0, i=p+1, ..., l-1 u_i := v_i, i=l, ..., m-1 b := su_p (so b = -|u|^2/2) Q := ( I_m + b^{-1}uu^T if b != 0 ( I_m if b = 0</p>
<p>After this, we place the non-zero components of u and y into the storage previously occupied by v; we let v_p := y_p and store u_p separately.</p>
<p>To apply this transformation to the set of m-vectors c_j, getting d_j = Qc_j, we do: </p>
<pre class="fragment">     t_j := b^{-1}(u^T c_j)
     d_j := c_j + t_j u
</pre><p>if b != 0, and d_j := c_j if b = 0.</p>
<p>This function computes u, b, y:=Qv and d_j := Qc_j for all c_j we are given. If u and y have already been computed, we can apply this Q to new c_j vectors.</p>
<p>Arguments: mode: 1 means calculate u, b, y and then Qc_j 2 means u and y are precalculated, just calculate Qc_j v, the vector to pivot NB this vector is modified during execution of this function, as described above p, the pivot l, the zeroing point m, the length of the vector v u_p (double *), the calculated value of u_p C, double **C, array of pointers to the c_j vectors nC, number of c_j vectors If C=NULL or nC=0, the code will not attempt to find any Qc_j. NB the calculated d_j := Qc_j vectors will overwrite the C array</p>
<p>Here is the collected algorithm, as outlined above:</p>
<p>0 // Start here if mode = 1 1 s := sqrt(v_p^2 + sum_{i=l}^{m-1} v_i^2) (Use the calculation trick described below under Givens transformations to avoid calculation errors) 2 if v_p &gt; 0, s := -s 3 u_p := v_p - s, v_p := s 4 // Start here if mode = 2 5 b := v_p.u_p 6 if b=0 or no C, stop 7 for each c_j do steps 8-10 8 t_j := (c_j[p].u_p + sum_{i=l}^{m-1} c_j[i].v_i) / b 9 c_j[p] := c_j[p] + t_j.u_p 10 for i=l,...,m-1, c_j[i] := c_j[i] + t_j.v_i </p>

<p>Definition at line <a class="el" href="_g_c_i___lsqnonneg_8c_source.html#l00159">159</a> of file <a class="el" href="_g_c_i___lsqnonneg_8c_source.html">GCI_Lsqnonneg.c</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Mar 11 2014 15:45:15 for SLIM Curve by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
