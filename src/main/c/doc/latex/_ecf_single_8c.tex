\hypertarget{_ecf_single_8c}{\section{Ecf\-Single.\-c File Reference}
\label{_ecf_single_8c}\index{Ecf\-Single.\-c@{Ecf\-Single.\-c}}
}


S\-L\-I\-M Curve -\/ Exponential Curve Fitting.  


{\ttfamily \#include $<$math.\-h$>$}\\*
{\ttfamily \#include $<$stdio.\-h$>$}\\*
{\ttfamily \#include $<$stdlib.\-h$>$}\\*
{\ttfamily \#include \char`\"{}Ecf\-Internal.\-h\char`\"{}}\\*
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define {\bfseries do\-\_\-frees}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\hypertarget{_ecf_single_8c_a12f94f60ba55450a3c96ff5354f4e196}{int {\bfseries G\-C\-I\-\_\-marquardt\-\_\-step} (float x\mbox{[}$\,$\mbox{]}, float y\mbox{[}$\,$\mbox{]}, int ndata, \hyperlink{_ecf_8h_a603ad628eaeb162f9f6326cbec927b89}{noise\-\_\-type} noise, float sig\mbox{[}$\,$\mbox{]}, float param\mbox{[}$\,$\mbox{]}, int paramfree\mbox{[}$\,$\mbox{]}, int nparam, \hyperlink{_ecf_8h_ab577c048e57126ea37f6656e97e547e7}{restrain\-\_\-type} restrain, void($\ast$fitfunc)(float, float\mbox{[}$\,$\mbox{]}, float $\ast$, float\mbox{[}$\,$\mbox{]}, int), float yfit\mbox{[}$\,$\mbox{]}, float dy\mbox{[}$\,$\mbox{]}, float $\ast$$\ast$covar, float $\ast$$\ast$alpha, float $\ast$chisq, float $\ast$alambda, int $\ast$pmfit, float $\ast$pochisq, float $\ast$paramtry, float $\ast$beta, float $\ast$dparam)}\label{_ecf_single_8c_a12f94f60ba55450a3c96ff5354f4e196}

\item 
\hypertarget{_ecf_single_8c_afb8daa724709f15dfe9b3b95d7e2c5ca}{int {\bfseries G\-C\-I\-\_\-marquardt\-\_\-step\-\_\-instr} (float xincr, float y\mbox{[}$\,$\mbox{]}, int ndata, int fit\-\_\-start, int fit\-\_\-end, float instr\mbox{[}$\,$\mbox{]}, int ninstr, \hyperlink{_ecf_8h_a603ad628eaeb162f9f6326cbec927b89}{noise\-\_\-type} noise, float sig\mbox{[}$\,$\mbox{]}, float param\mbox{[}$\,$\mbox{]}, int paramfree\mbox{[}$\,$\mbox{]}, int nparam, \hyperlink{_ecf_8h_ab577c048e57126ea37f6656e97e547e7}{restrain\-\_\-type} restrain, void($\ast$fitfunc)(float, float\mbox{[}$\,$\mbox{]}, float $\ast$, float\mbox{[}$\,$\mbox{]}, int), float yfit\mbox{[}$\,$\mbox{]}, float dy\mbox{[}$\,$\mbox{]}, float $\ast$$\ast$covar, float $\ast$$\ast$alpha, float $\ast$chisq, float $\ast$alambda, int $\ast$pmfit, float $\ast$pochisq, float $\ast$paramtry, float $\ast$beta, float $\ast$dparam, float $\ast$$\ast$pfnvals, float $\ast$$\ast$$\ast$pdy\-\_\-dparam\-\_\-pure, float $\ast$$\ast$$\ast$pdy\-\_\-dparam\-\_\-conv, int $\ast$pfnvals\-\_\-len, int $\ast$pdy\-\_\-dparam\-\_\-nparam\-\_\-size)}\label{_ecf_single_8c_afb8daa724709f15dfe9b3b95d7e2c5ca}

\item 
\hypertarget{_ecf_single_8c_a5be7339bce1cb57d8723988385b82b5e}{int {\bfseries G\-C\-I\-\_\-marquardt\-\_\-estimate\-\_\-errors} (float $\ast$$\ast$alpha, int nparam, int mfit, float d\mbox{[}$\,$\mbox{]}, float $\ast$$\ast$v, float interval)}\label{_ecf_single_8c_a5be7339bce1cb57d8723988385b82b5e}

\item 
int \hyperlink{_ecf_single_8c_ad62c421e86238246287fc9cadf4bf171}{G\-C\-I\-\_\-triple\-\_\-integral} (float xincr, float y\mbox{[}$\,$\mbox{]}, int fit\-\_\-start, int fit\-\_\-end, \hyperlink{_ecf_8h_a603ad628eaeb162f9f6326cbec927b89}{noise\-\_\-type} noise, float sig\mbox{[}$\,$\mbox{]}, float $\ast$Z, float $\ast$A, float $\ast$tau, float $\ast$fitted, float $\ast$residuals, float $\ast$chisq, int division)
\begin{DoxyCompactList}\small\item\em Start with an easy one\-: the three integral method. \end{DoxyCompactList}\item 
\hypertarget{_ecf_single_8c_a3c72ce45f467e73bdbfdeecba86a2d3a}{int {\bfseries G\-C\-I\-\_\-triple\-\_\-integral\-\_\-instr} (float xincr, float y\mbox{[}$\,$\mbox{]}, int fit\-\_\-start, int fit\-\_\-end, float instr\mbox{[}$\,$\mbox{]}, int ninstr, \hyperlink{_ecf_8h_a603ad628eaeb162f9f6326cbec927b89}{noise\-\_\-type} noise, float sig\mbox{[}$\,$\mbox{]}, float $\ast$Z, float $\ast$A, float $\ast$tau, float $\ast$fitted, float $\ast$residuals, float $\ast$chisq, int division)}\label{_ecf_single_8c_a3c72ce45f467e73bdbfdeecba86a2d3a}

\item 
int \hyperlink{_ecf_single_8c_a7790a7e8ebdca31efd349e44add17cd9}{G\-C\-I\-\_\-triple\-\_\-integral\-\_\-fitting\-\_\-engine} (float xincr, float y\mbox{[}$\,$\mbox{]}, int fit\-\_\-start, int fit\-\_\-end, float instr\mbox{[}$\,$\mbox{]}, int ninstr, \hyperlink{_ecf_8h_a603ad628eaeb162f9f6326cbec927b89}{noise\-\_\-type} noise, float sig\mbox{[}$\,$\mbox{]}, float $\ast$Z, float $\ast$A, float $\ast$tau, float $\ast$fitted, float $\ast$residuals, float $\ast$chisq, float chisq\-\_\-target)
\begin{DoxyCompactList}\small\item\em The main entry point for Triple Integral or Rapid Lifetime Determination (R\-L\-D). \end{DoxyCompactList}\item 
int \hyperlink{_ecf_single_8c_a5bbaf55df7653f2f443e38b6f6b1e1a9}{G\-C\-I\-\_\-marquardt} (float x\mbox{[}$\,$\mbox{]}, float y\mbox{[}$\,$\mbox{]}, int ndata, \hyperlink{_ecf_8h_a603ad628eaeb162f9f6326cbec927b89}{noise\-\_\-type} noise, float sig\mbox{[}$\,$\mbox{]}, float param\mbox{[}$\,$\mbox{]}, int paramfree\mbox{[}$\,$\mbox{]}, int nparam, \hyperlink{_ecf_8h_ab577c048e57126ea37f6656e97e547e7}{restrain\-\_\-type} restrain, void($\ast$fitfunc)(float, float\mbox{[}$\,$\mbox{]}, float $\ast$, float\mbox{[}$\,$\mbox{]}, int), float $\ast$fitted, float $\ast$residuals, float $\ast$$\ast$covar, float $\ast$$\ast$alpha, float $\ast$chisq, float chisq\-\_\-delta, float chisq\-\_\-percent, float $\ast$$\ast$erraxes)
\begin{DoxyCompactList}\small\item\em Now for the non-\/linear least squares fitting algorithms. \end{DoxyCompactList}\item 
\hypertarget{_ecf_single_8c_a527b18f8e48919e46f32af4889662f48}{int {\bfseries G\-C\-I\-\_\-marquardt\-\_\-instr} (float xincr, float y\mbox{[}$\,$\mbox{]}, int ndata, int fit\-\_\-start, int fit\-\_\-end, float instr\mbox{[}$\,$\mbox{]}, int ninstr, \hyperlink{_ecf_8h_a603ad628eaeb162f9f6326cbec927b89}{noise\-\_\-type} noise, float sig\mbox{[}$\,$\mbox{]}, float param\mbox{[}$\,$\mbox{]}, int paramfree\mbox{[}$\,$\mbox{]}, int nparam, \hyperlink{_ecf_8h_ab577c048e57126ea37f6656e97e547e7}{restrain\-\_\-type} restrain, void($\ast$fitfunc)(float, float\mbox{[}$\,$\mbox{]}, float $\ast$, float\mbox{[}$\,$\mbox{]}, int), float $\ast$fitted, float $\ast$residuals, float $\ast$$\ast$covar, float $\ast$$\ast$alpha, float $\ast$chisq, float chisq\-\_\-delta, float chisq\-\_\-percent, float $\ast$$\ast$erraxes)}\label{_ecf_single_8c_a527b18f8e48919e46f32af4889662f48}

\item 
int \hyperlink{_ecf_single_8c_a2f0e656f93772e14f4a879297e17556f}{G\-C\-I\-\_\-marquardt\-\_\-compute\-\_\-fn} (float x\mbox{[}$\,$\mbox{]}, float y\mbox{[}$\,$\mbox{]}, int ndata, \hyperlink{_ecf_8h_a603ad628eaeb162f9f6326cbec927b89}{noise\-\_\-type} noise, float sig\mbox{[}$\,$\mbox{]}, float param\mbox{[}$\,$\mbox{]}, int paramfree\mbox{[}$\,$\mbox{]}, int nparam, void($\ast$fitfunc)(float, float\mbox{[}$\,$\mbox{]}, float $\ast$, float\mbox{[}$\,$\mbox{]}, int), float yfit\mbox{[}$\,$\mbox{]}, float dy\mbox{[}$\,$\mbox{]}, float $\ast$$\ast$alpha, float beta\mbox{[}$\,$\mbox{]}, float $\ast$chisq, float old\-\_\-chisq, float alambda)
\begin{DoxyCompactList}\small\item\em Used by G\-C\-I\-\_\-marquardt to evaluate the linearised fitting matrix alpha and vector beta and to calculate chi$^\wedge$2. \end{DoxyCompactList}\item 
\hypertarget{_ecf_single_8c_ad97ce4de715a51cf1fba23af5309e32e}{int {\bfseries G\-C\-I\-\_\-marquardt\-\_\-compute\-\_\-fn\-\_\-instr} (float xincr, float y\mbox{[}$\,$\mbox{]}, int ndata, int fit\-\_\-start, int fit\-\_\-end, float instr\mbox{[}$\,$\mbox{]}, int ninstr, \hyperlink{_ecf_8h_a603ad628eaeb162f9f6326cbec927b89}{noise\-\_\-type} noise, float sig\mbox{[}$\,$\mbox{]}, float param\mbox{[}$\,$\mbox{]}, int paramfree\mbox{[}$\,$\mbox{]}, int nparam, void($\ast$fitfunc)(float, float\mbox{[}$\,$\mbox{]}, float $\ast$, float\mbox{[}$\,$\mbox{]}, int), float yfit\mbox{[}$\,$\mbox{]}, float dy\mbox{[}$\,$\mbox{]}, float $\ast$$\ast$alpha, float beta\mbox{[}$\,$\mbox{]}, float $\ast$chisq, float old\-\_\-chisq, float alambda, float $\ast$$\ast$pfnvals, float $\ast$$\ast$$\ast$pdy\-\_\-dparam\-\_\-pure, float $\ast$$\ast$$\ast$pdy\-\_\-dparam\-\_\-conv, int $\ast$pfnvals\-\_\-len, int $\ast$pdy\-\_\-dparam\-\_\-nparam\-\_\-size)}\label{_ecf_single_8c_ad97ce4de715a51cf1fba23af5309e32e}

\item 
int \hyperlink{_ecf_single_8c_aa71017f42eaaac4f5246ba5c931e0838}{G\-C\-I\-\_\-marquardt\-\_\-compute\-\_\-fn\-\_\-final} (float x\mbox{[}$\,$\mbox{]}, float y\mbox{[}$\,$\mbox{]}, int ndata, \hyperlink{_ecf_8h_a603ad628eaeb162f9f6326cbec927b89}{noise\-\_\-type} noise, float sig\mbox{[}$\,$\mbox{]}, float param\mbox{[}$\,$\mbox{]}, int paramfree\mbox{[}$\,$\mbox{]}, int nparam, void($\ast$fitfunc)(float, float\mbox{[}$\,$\mbox{]}, float $\ast$, float\mbox{[}$\,$\mbox{]}, int), float yfit\mbox{[}$\,$\mbox{]}, float dy\mbox{[}$\,$\mbox{]}, float $\ast$chisq)
\begin{DoxyCompactList}\small\item\em These two variants, used just before the Marquardt fitting functions terminate, compute the function values at all points, whether or not they are being fitted. \end{DoxyCompactList}\item 
int \hyperlink{_ecf_single_8c_ae3621766e57085ea7fa13b6533cd0bb8}{G\-C\-I\-\_\-marquardt\-\_\-compute\-\_\-fn\-\_\-final\-\_\-instr} (float xincr, float y\mbox{[}$\,$\mbox{]}, int ndata, int fit\-\_\-start, int fit\-\_\-end, float instr\mbox{[}$\,$\mbox{]}, int ninstr, \hyperlink{_ecf_8h_a603ad628eaeb162f9f6326cbec927b89}{noise\-\_\-type} noise, float sig\mbox{[}$\,$\mbox{]}, float param\mbox{[}$\,$\mbox{]}, int paramfree\mbox{[}$\,$\mbox{]}, int nparam, void($\ast$fitfunc)(float, float\mbox{[}$\,$\mbox{]}, float $\ast$, float\mbox{[}$\,$\mbox{]}, int), float yfit\mbox{[}$\,$\mbox{]}, float dy\mbox{[}$\,$\mbox{]}, float $\ast$chisq, float $\ast$$\ast$pfnvals, float $\ast$$\ast$$\ast$pdy\-\_\-dparam\-\_\-pure, float $\ast$$\ast$$\ast$pdy\-\_\-dparam\-\_\-conv, int $\ast$pfnvals\-\_\-len, int $\ast$pdy\-\_\-dparam\-\_\-nparam\-\_\-size)
\begin{DoxyCompactList}\small\item\em And this is the variant which handles an instrument response. \end{DoxyCompactList}\item 
int \hyperlink{_ecf_single_8c_a94bbfd4c5b3d3a79fd840731954f3976}{G\-C\-I\-\_\-marquardt\-\_\-fitting\-\_\-engine} (float xincr, float $\ast$trans, int ndata, int fit\-\_\-start, int fit\-\_\-end, float prompt\mbox{[}$\,$\mbox{]}, int nprompt, \hyperlink{_ecf_8h_a603ad628eaeb162f9f6326cbec927b89}{noise\-\_\-type} noise, float sig\mbox{[}$\,$\mbox{]}, float param\mbox{[}$\,$\mbox{]}, int paramfree\mbox{[}$\,$\mbox{]}, int nparam, \hyperlink{_ecf_8h_ab577c048e57126ea37f6656e97e547e7}{restrain\-\_\-type} restrain, void($\ast$fitfunc)(float, float\mbox{[}$\,$\mbox{]}, float $\ast$, float\mbox{[}$\,$\mbox{]}, int), float $\ast$fitted, float $\ast$residuals, float $\ast$chisq, float $\ast$$\ast$covar, float $\ast$$\ast$alpha, float $\ast$$\ast$erraxes, float chisq\-\_\-target, float chisq\-\_\-delta, int chisq\-\_\-percent)
\begin{DoxyCompactList}\small\item\em G\-C\-I\-\_\-marquardt\-\_\-fitting\-\_\-engine. \end{DoxyCompactList}\item 
\hypertarget{_ecf_single_8c_a26e45e21bc6592ea929a9b103fe9c4d2}{void {\bfseries G\-C\-I\-\_\-marquardt\-\_\-cleanup} (void)}\label{_ecf_single_8c_a26e45e21bc6592ea929a9b103fe9c4d2}

\end{DoxyCompactItemize}


\subsection{Detailed Description}
S\-L\-I\-M Curve -\/ Exponential Curve Fitting. Based on the 2003 version of the E\-C\-F library. This has been modified to remove modified Numeric Recipes code. Also, this takes account of the fact that we may be handling Poisson noise.

This file contains functions for single transient analysis. Utility code is found in Ecf\-Util.\-c and global analysis code in \hyperlink{_ecf_global_8c_source}{Ecf\-Global.\-c}. 

Definition in file \hyperlink{_ecf_single_8c_source}{Ecf\-Single.\-c}.



\subsection{Macro Definition Documentation}
\hypertarget{_ecf_single_8c_af5f941a121d48cfb608cdd4a63a1f430}{\index{Ecf\-Single.\-c@{Ecf\-Single.\-c}!do\-\_\-frees@{do\-\_\-frees}}
\index{do\-\_\-frees@{do\-\_\-frees}!EcfSingle.c@{Ecf\-Single.\-c}}
\subsubsection[{do\-\_\-frees}]{\setlength{\rightskip}{0pt plus 5cm}\#define do\-\_\-frees}}\label{_ecf_single_8c_af5f941a121d48cfb608cdd4a63a1f430}
{\bfseries Value\-:}
\begin{DoxyCode}
\textcolor{keywordflow}{if} (fnvals) free(fnvals);\(\backslash\)
    if (dy\_dparam\_pure) GCI\_ecf\_free\_matrix(dy\_dparam\_pure);\(\backslash\)
    if (dy\_dparam\_conv) GCI\_ecf\_free\_matrix(dy\_dparam\_conv);
\end{DoxyCode}


Definition at line 606 of file Ecf\-Single.\-c.



\subsection{Function Documentation}
\hypertarget{_ecf_single_8c_a5bbaf55df7653f2f443e38b6f6b1e1a9}{\index{Ecf\-Single.\-c@{Ecf\-Single.\-c}!G\-C\-I\-\_\-marquardt@{G\-C\-I\-\_\-marquardt}}
\index{G\-C\-I\-\_\-marquardt@{G\-C\-I\-\_\-marquardt}!EcfSingle.c@{Ecf\-Single.\-c}}
\subsubsection[{G\-C\-I\-\_\-marquardt}]{\setlength{\rightskip}{0pt plus 5cm}int G\-C\-I\-\_\-marquardt (
\begin{DoxyParamCaption}
\item[{float}]{x\mbox{[}$\,$\mbox{]}, }
\item[{float}]{y\mbox{[}$\,$\mbox{]}, }
\item[{int}]{ndata, }
\item[{{\bf noise\-\_\-type}}]{noise, }
\item[{float}]{sig\mbox{[}$\,$\mbox{]}, }
\item[{float}]{param\mbox{[}$\,$\mbox{]}, }
\item[{int}]{paramfree\mbox{[}$\,$\mbox{]}, }
\item[{int}]{nparam, }
\item[{{\bf restrain\-\_\-type}}]{restrain, }
\item[{void($\ast$)(float, float\mbox{[}$\,$\mbox{]}, float $\ast$, float\mbox{[}$\,$\mbox{]}, int)}]{fitfunc, }
\item[{float $\ast$}]{fitted, }
\item[{float $\ast$}]{residuals, }
\item[{float $\ast$$\ast$}]{covar, }
\item[{float $\ast$$\ast$}]{alpha, }
\item[{float $\ast$}]{chisq, }
\item[{float}]{chisq\-\_\-delta, }
\item[{float}]{chisq\-\_\-percent, }
\item[{float $\ast$$\ast$}]{erraxes}
\end{DoxyParamCaption}
)}}\label{_ecf_single_8c_a5bbaf55df7653f2f443e38b6f6b1e1a9}


Now for the non-\/linear least squares fitting algorithms. 

The process is\-:
\begin{DoxyItemize}
\item for Gaussian noise, use Levenberg-\/\-Marquardt directly
\item for Poisson noise, use Levenberg-\/\-Marquardt to get an initial estimate of the parameters assuming constant error variance, then use amoeba to improve the estimate, assuming that the error variance is proportional to the function value (with a minimum variance of 15 to handle the case when the Poisson distribution is not approximately Gaussian, so that the very noisy tails do not inappropriately weight the solution).
\end{DoxyItemize}

This code contains two variants of the Levenberg-\/\-Marquardt method for slightly different situations. This attempts to reduce the value chi$^\wedge$2 of a fit between a set of data points x\mbox{[}0..ndata-\/1\mbox{]}, y\mbox{[}0..ndata-\/1\mbox{]} and a nonlinear function dependent on nparam coefficients param\mbox{[}0..nparam-\/1\mbox{]}. In the case that the x values are equally spaced and start at zero, we can also handle convolution with an instrument response instr\mbox{[}0..ninstr-\/1\mbox{]} and only look at the data points from fit\-\_\-start..fit\-\_\-end-\/1. The first variant does not handle an instrument response and takes any values of x\mbox{[}0..ndata-\/1\mbox{]}. The second variant takes an xincr and will handle an instrument response if ninstr $>$ 0. The individual standard deviations of the errors are determined by the value of noise\-: if noise=N\-O\-I\-S\-E\-\_\-\-C\-O\-N\-S\-T, the standard deviations are constant, given by sig\mbox{[}0\mbox{]}=$\ast$sig, if noise=N\-O\-I\-S\-E\-\_\-\-G\-I\-V\-E\-N, the standard deviations are given by sig\mbox{[}0..ndata-\/1\mbox{]}, if noise=N\-O\-I\-S\-E\-\_\-\-P\-O\-I\-S\-S\-O\-N\-\_\-\-D\-A\-T\-A, the standard deviations are taken to be given by Poisson noise, and the variances are taken to be max(y\mbox{[}i\mbox{]},15), and if noise=N\-O\-I\-S\-E\-\_\-\-P\-O\-I\-S\-S\-O\-N\-\_\-\-F\-I\-T, the variances are taken to be max(yfit\mbox{[}i\mbox{]},15). If noise=N\-O\-I\-S\-E\-\_\-\-G\-A\-U\-S\-S\-I\-A\-N\-\_\-\-F\-I\-T, the variances are taken to be yfit\mbox{[}i\mbox{]} and if noise=N\-O\-I\-S\-E\-\_\-\-M\-L\-E then a optimisation is for the maximum likelihood approximation (Laurence and Chromy in press 2010 and G. Nishimura, and M. Tamura Phys Med Biol 2005).

The input array paramfree\mbox{[}0..nparam-\/1\mbox{]} indicates by nonzero entries those components that should be held fixed at their input values. The program returns current best-\/fit values for the parameters param\mbox{[}0..nparam-\/1\mbox{]} and chi$^\wedge$2 = chisq. The arrays covar\mbox{[}0..nparam-\/1\mbox{]}\mbox{[}0..nparam-\/1\mbox{]} and alpha\mbox{[}0..nparam-\/1\mbox{]}\mbox{[}0..nparam-\/1\mbox{]} are used as working space during most isterations. Supply a routine fitfunc(x,param,yfit,dy\-\_\-dparam,nparam) that evaluates the fitting function fitfunc and its derivatives dydy\mbox{[}1..nparam-\/1\mbox{]} with respect to the fitting parameters param at x. (See below for information about zero offsets, though.) The values of fitfunc, modified by the instrument response, are returned in the array yfit and the differences y -\/ yfit in dy. The first call {\itshape must} provide an initial guess for the parameters param and set alambda $<$ 0 for initialisation (which then sets alambda = 0.\-001). If a step succeeds, chisq becomes smaller and alambda decreases by a factor of 10. You must call this routine repeatedly until convergence is achieved. Then make one final call with alambda=0 to perform cleanups and so that covar\mbox{[}0..nparam-\/1\mbox{]}\mbox{[}0..nparam-\/1\mbox{]} returns the covariance matrix and alpha the curvature matrix. (Parameters held fixed will return zero covariances.)

One key extra piece which is particularly important in the instrument response case. The parameter param\mbox{[}0\mbox{]} is assumed to be the zero offset of the signal, which applies before and after time zero. It thus simply contributes param\mbox{[}0\mbox{]}$\ast$sum(instr) to the signal value rather than being convolved with the instrument response only from time zero. For this reason, the fitfunc should ignore param\mbox{[}0\mbox{]}, as the fitting routines will handle this offset. 

Definition at line 526 of file Ecf\-Single.\-c.

\hypertarget{_ecf_single_8c_a2f0e656f93772e14f4a879297e17556f}{\index{Ecf\-Single.\-c@{Ecf\-Single.\-c}!G\-C\-I\-\_\-marquardt\-\_\-compute\-\_\-fn@{G\-C\-I\-\_\-marquardt\-\_\-compute\-\_\-fn}}
\index{G\-C\-I\-\_\-marquardt\-\_\-compute\-\_\-fn@{G\-C\-I\-\_\-marquardt\-\_\-compute\-\_\-fn}!EcfSingle.c@{Ecf\-Single.\-c}}
\subsubsection[{G\-C\-I\-\_\-marquardt\-\_\-compute\-\_\-fn}]{\setlength{\rightskip}{0pt plus 5cm}int G\-C\-I\-\_\-marquardt\-\_\-compute\-\_\-fn (
\begin{DoxyParamCaption}
\item[{float}]{x\mbox{[}$\,$\mbox{]}, }
\item[{float}]{y\mbox{[}$\,$\mbox{]}, }
\item[{int}]{ndata, }
\item[{{\bf noise\-\_\-type}}]{noise, }
\item[{float}]{sig\mbox{[}$\,$\mbox{]}, }
\item[{float}]{param\mbox{[}$\,$\mbox{]}, }
\item[{int}]{paramfree\mbox{[}$\,$\mbox{]}, }
\item[{int}]{nparam, }
\item[{void($\ast$)(float, float\mbox{[}$\,$\mbox{]}, float $\ast$, float\mbox{[}$\,$\mbox{]}, int)}]{fitfunc, }
\item[{float}]{yfit\mbox{[}$\,$\mbox{]}, }
\item[{float}]{dy\mbox{[}$\,$\mbox{]}, }
\item[{float $\ast$$\ast$}]{alpha, }
\item[{float}]{beta\mbox{[}$\,$\mbox{]}, }
\item[{float $\ast$}]{chisq, }
\item[{float}]{old\-\_\-chisq, }
\item[{float}]{alambda}
\end{DoxyParamCaption}
)}}\label{_ecf_single_8c_a2f0e656f93772e14f4a879297e17556f}


Used by G\-C\-I\-\_\-marquardt to evaluate the linearised fitting matrix alpha and vector beta and to calculate chi$^\wedge$2. 

The equations involved are given in section 15.\-5 of Numerical Recipes; basically\-:

$^\wedge$2(param) = \{i=1\}$^\wedge$\-N ( (y\-\_\-i-\/y(x\-\_\-i;param)) / sigma\-\_\-i )$^\wedge$2

beta\-\_\-k = -\/1/2 (d/dparam\-\_\-k)(chi$^\wedge$2)

alpha\-\_\-kl = \{i=1\}$^\wedge$\-N (1/sigma\-\_\-i$^\wedge$2) . (dy(x\-\_\-i;param)/dparam\-\_\-k) . (dy(x\-\_\-i;param)/dparam\-\_\-l)

(where all of the derivatives are partial).

If an instrument response is provided, we also take account of it now. We are given that\-:

observed(t) = response(t) $\ast$ instr(t)

where response(t) is being fitted with fitfunc; it is also trivial to show that (assuming that instr(t) is known and fixed, with no dependencies on the param\-\_\-k, the parameters being fitted)\-:

(d/dparam\-\_\-k) observed(t) = ((d/dparam\-\_\-k) response(t)) $\ast$ instr(t)

so we do not need to alter the response function in any way to determined the fitted convolved response.

Again there are two variants of this function, corresponding to the two variants of the Marquardt function. 

Definition at line 998 of file Ecf\-Single.\-c.

\hypertarget{_ecf_single_8c_aa71017f42eaaac4f5246ba5c931e0838}{\index{Ecf\-Single.\-c@{Ecf\-Single.\-c}!G\-C\-I\-\_\-marquardt\-\_\-compute\-\_\-fn\-\_\-final@{G\-C\-I\-\_\-marquardt\-\_\-compute\-\_\-fn\-\_\-final}}
\index{G\-C\-I\-\_\-marquardt\-\_\-compute\-\_\-fn\-\_\-final@{G\-C\-I\-\_\-marquardt\-\_\-compute\-\_\-fn\-\_\-final}!EcfSingle.c@{Ecf\-Single.\-c}}
\subsubsection[{G\-C\-I\-\_\-marquardt\-\_\-compute\-\_\-fn\-\_\-final}]{\setlength{\rightskip}{0pt plus 5cm}int G\-C\-I\-\_\-marquardt\-\_\-compute\-\_\-fn\-\_\-final (
\begin{DoxyParamCaption}
\item[{float}]{x\mbox{[}$\,$\mbox{]}, }
\item[{float}]{y\mbox{[}$\,$\mbox{]}, }
\item[{int}]{ndata, }
\item[{{\bf noise\-\_\-type}}]{noise, }
\item[{float}]{sig\mbox{[}$\,$\mbox{]}, }
\item[{float}]{param\mbox{[}$\,$\mbox{]}, }
\item[{int}]{paramfree\mbox{[}$\,$\mbox{]}, }
\item[{int}]{nparam, }
\item[{void($\ast$)(float, float\mbox{[}$\,$\mbox{]}, float $\ast$, float\mbox{[}$\,$\mbox{]}, int)}]{fitfunc, }
\item[{float}]{yfit\mbox{[}$\,$\mbox{]}, }
\item[{float}]{dy\mbox{[}$\,$\mbox{]}, }
\item[{float $\ast$}]{chisq}
\end{DoxyParamCaption}
)}}\label{_ecf_single_8c_aa71017f42eaaac4f5246ba5c931e0838}


These two variants, used just before the Marquardt fitting functions terminate, compute the function values at all points, whether or not they are being fitted. 

(All points are fitted in the non-\/instrument response variant.) They also compute the residuals y -\/ yfit at all of those points and compute a chi-\/squared value which is not modified at small data values in the P\-O\-I\-S\-S\-O\-N noise models. They do not calculate alpha or beta. 

Definition at line 1482 of file Ecf\-Single.\-c.

\hypertarget{_ecf_single_8c_ae3621766e57085ea7fa13b6533cd0bb8}{\index{Ecf\-Single.\-c@{Ecf\-Single.\-c}!G\-C\-I\-\_\-marquardt\-\_\-compute\-\_\-fn\-\_\-final\-\_\-instr@{G\-C\-I\-\_\-marquardt\-\_\-compute\-\_\-fn\-\_\-final\-\_\-instr}}
\index{G\-C\-I\-\_\-marquardt\-\_\-compute\-\_\-fn\-\_\-final\-\_\-instr@{G\-C\-I\-\_\-marquardt\-\_\-compute\-\_\-fn\-\_\-final\-\_\-instr}!EcfSingle.c@{Ecf\-Single.\-c}}
\subsubsection[{G\-C\-I\-\_\-marquardt\-\_\-compute\-\_\-fn\-\_\-final\-\_\-instr}]{\setlength{\rightskip}{0pt plus 5cm}int G\-C\-I\-\_\-marquardt\-\_\-compute\-\_\-fn\-\_\-final\-\_\-instr (
\begin{DoxyParamCaption}
\item[{float}]{xincr, }
\item[{float}]{y\mbox{[}$\,$\mbox{]}, }
\item[{int}]{ndata, }
\item[{int}]{fit\-\_\-start, }
\item[{int}]{fit\-\_\-end, }
\item[{float}]{instr\mbox{[}$\,$\mbox{]}, }
\item[{int}]{ninstr, }
\item[{{\bf noise\-\_\-type}}]{noise, }
\item[{float}]{sig\mbox{[}$\,$\mbox{]}, }
\item[{float}]{param\mbox{[}$\,$\mbox{]}, }
\item[{int}]{paramfree\mbox{[}$\,$\mbox{]}, }
\item[{int}]{nparam, }
\item[{void($\ast$)(float, float\mbox{[}$\,$\mbox{]}, float $\ast$, float\mbox{[}$\,$\mbox{]}, int)}]{fitfunc, }
\item[{float}]{yfit\mbox{[}$\,$\mbox{]}, }
\item[{float}]{dy\mbox{[}$\,$\mbox{]}, }
\item[{float $\ast$}]{chisq, }
\item[{float $\ast$$\ast$}]{pfnvals, }
\item[{float $\ast$$\ast$$\ast$}]{pdy\-\_\-dparam\-\_\-pure, }
\item[{float $\ast$$\ast$$\ast$}]{pdy\-\_\-dparam\-\_\-conv, }
\item[{int $\ast$}]{pfnvals\-\_\-len, }
\item[{int $\ast$}]{pdy\-\_\-dparam\-\_\-nparam\-\_\-size}
\end{DoxyParamCaption}
)}}\label{_ecf_single_8c_ae3621766e57085ea7fa13b6533cd0bb8}


And this is the variant which handles an instrument response. 

We assume that the function values are sensible. Note also that we have to be careful about which points which include in the chi-\/squared calculation. Also, we are guaranteed that the initialisation of the convolution arrays has been performed. 

Definition at line 1611 of file Ecf\-Single.\-c.

\hypertarget{_ecf_single_8c_a94bbfd4c5b3d3a79fd840731954f3976}{\index{Ecf\-Single.\-c@{Ecf\-Single.\-c}!G\-C\-I\-\_\-marquardt\-\_\-fitting\-\_\-engine@{G\-C\-I\-\_\-marquardt\-\_\-fitting\-\_\-engine}}
\index{G\-C\-I\-\_\-marquardt\-\_\-fitting\-\_\-engine@{G\-C\-I\-\_\-marquardt\-\_\-fitting\-\_\-engine}!EcfSingle.c@{Ecf\-Single.\-c}}
\subsubsection[{G\-C\-I\-\_\-marquardt\-\_\-fitting\-\_\-engine}]{\setlength{\rightskip}{0pt plus 5cm}int G\-C\-I\-\_\-marquardt\-\_\-fitting\-\_\-engine (
\begin{DoxyParamCaption}
\item[{float}]{xincr, }
\item[{float $\ast$}]{trans, }
\item[{int}]{ndata, }
\item[{int}]{fit\-\_\-start, }
\item[{int}]{fit\-\_\-end, }
\item[{float}]{prompt\mbox{[}$\,$\mbox{]}, }
\item[{int}]{nprompt, }
\item[{{\bf noise\-\_\-type}}]{noise, }
\item[{float}]{sig\mbox{[}$\,$\mbox{]}, }
\item[{float}]{param\mbox{[}$\,$\mbox{]}, }
\item[{int}]{paramfree\mbox{[}$\,$\mbox{]}, }
\item[{int}]{nparam, }
\item[{{\bf restrain\-\_\-type}}]{restrain, }
\item[{void($\ast$)(float, float\mbox{[}$\,$\mbox{]}, float $\ast$, float\mbox{[}$\,$\mbox{]}, int)}]{fitfunc, }
\item[{float $\ast$}]{fitted, }
\item[{float $\ast$}]{residuals, }
\item[{float $\ast$}]{chisq, }
\item[{float $\ast$$\ast$}]{covar, }
\item[{float $\ast$$\ast$}]{alpha, }
\item[{float $\ast$$\ast$}]{erraxes, }
\item[{float}]{chisq\-\_\-target, }
\item[{float}]{chisq\-\_\-delta, }
\item[{int}]{chisq\-\_\-percent}
\end{DoxyParamCaption}
)}}\label{_ecf_single_8c_a94bbfd4c5b3d3a79fd840731954f3976}


G\-C\-I\-\_\-marquardt\-\_\-fitting\-\_\-engine. 

The main entry point for L\-M and M\-L\-E fitting.

This returns the number of iterations or negative if an error occurred. passes all the data to the ecf routine, checks the returned chisq and re-\/fits if it is of benefit was Do\-Ecf\-Fitting\-Engine() included in \hyperlink{_ecf_single_8c}{Ecf\-Single.\-c} by P\-R\-B, 3.\-9.\-03 

Definition at line 1860 of file Ecf\-Single.\-c.

\hypertarget{_ecf_single_8c_ad62c421e86238246287fc9cadf4bf171}{\index{Ecf\-Single.\-c@{Ecf\-Single.\-c}!G\-C\-I\-\_\-triple\-\_\-integral@{G\-C\-I\-\_\-triple\-\_\-integral}}
\index{G\-C\-I\-\_\-triple\-\_\-integral@{G\-C\-I\-\_\-triple\-\_\-integral}!EcfSingle.c@{Ecf\-Single.\-c}}
\subsubsection[{G\-C\-I\-\_\-triple\-\_\-integral}]{\setlength{\rightskip}{0pt plus 5cm}int G\-C\-I\-\_\-triple\-\_\-integral (
\begin{DoxyParamCaption}
\item[{float}]{xincr, }
\item[{float}]{y\mbox{[}$\,$\mbox{]}, }
\item[{int}]{fit\-\_\-start, }
\item[{int}]{fit\-\_\-end, }
\item[{{\bf noise\-\_\-type}}]{noise, }
\item[{float}]{sig\mbox{[}$\,$\mbox{]}, }
\item[{float $\ast$}]{Z, }
\item[{float $\ast$}]{A, }
\item[{float $\ast$}]{tau, }
\item[{float $\ast$}]{fitted, }
\item[{float $\ast$}]{residuals, }
\item[{float $\ast$}]{chisq, }
\item[{int}]{division}
\end{DoxyParamCaption}
)}}\label{_ecf_single_8c_ad62c421e86238246287fc9cadf4bf171}


Start with an easy one\-: the three integral method. 

This returns 0 on success, negative on error. 

Definition at line 77 of file Ecf\-Single.\-c.

\hypertarget{_ecf_single_8c_a7790a7e8ebdca31efd349e44add17cd9}{\index{Ecf\-Single.\-c@{Ecf\-Single.\-c}!G\-C\-I\-\_\-triple\-\_\-integral\-\_\-fitting\-\_\-engine@{G\-C\-I\-\_\-triple\-\_\-integral\-\_\-fitting\-\_\-engine}}
\index{G\-C\-I\-\_\-triple\-\_\-integral\-\_\-fitting\-\_\-engine@{G\-C\-I\-\_\-triple\-\_\-integral\-\_\-fitting\-\_\-engine}!EcfSingle.c@{Ecf\-Single.\-c}}
\subsubsection[{G\-C\-I\-\_\-triple\-\_\-integral\-\_\-fitting\-\_\-engine}]{\setlength{\rightskip}{0pt plus 5cm}int G\-C\-I\-\_\-triple\-\_\-integral\-\_\-fitting\-\_\-engine (
\begin{DoxyParamCaption}
\item[{float}]{xincr, }
\item[{float}]{y\mbox{[}$\,$\mbox{]}, }
\item[{int}]{fit\-\_\-start, }
\item[{int}]{fit\-\_\-end, }
\item[{float}]{instr\mbox{[}$\,$\mbox{]}, }
\item[{int}]{ninstr, }
\item[{{\bf noise\-\_\-type}}]{noise, }
\item[{float}]{sig\mbox{[}$\,$\mbox{]}, }
\item[{float $\ast$}]{Z, }
\item[{float $\ast$}]{A, }
\item[{float $\ast$}]{tau, }
\item[{float $\ast$}]{fitted, }
\item[{float $\ast$}]{residuals, }
\item[{float $\ast$}]{chisq, }
\item[{float}]{chisq\-\_\-target}
\end{DoxyParamCaption}
)}}\label{_ecf_single_8c_a7790a7e8ebdca31efd349e44add17cd9}


The main entry point for Triple Integral or Rapid Lifetime Determination (R\-L\-D). 

Uses G\-C\-I\-\_\-triple\-\_\-integral\-\_\-$\ast$() to fit repeatedly with different integration periods until chisq\-\_\-target is met or a maximum number of iterations are used.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em xincr} & The time increment inbetween the values in the y array. \\
\hline
\mbox{\tt in}  & {\em y} & The transient (time resolved) signal to be analysed, the 'data'. \\
\hline
\mbox{\tt in}  & {\em fit\-\_\-start} & The index into the y array marking the start to the data to be used in the fit. \\
\hline
\mbox{\tt in}  & {\em fit\-\_\-end} & The index into the y array marking the end of the data to be used in the fit. \\
\hline
\mbox{\tt in}  & {\em instr} & The instrument reponse (I\-R\-F) or prompt signal to be used (optional, can pass N\-U\-L\-L). \\
\hline
\mbox{\tt in}  & {\em noise} & The noise\-\_\-type to be used. \\
\hline
\mbox{\tt in}  & {\em sig} & The standard deviation at each data point in y if noise\-\_\-type N\-O\-I\-S\-E\-\_\-\-G\-I\-V\-E\-N is used (optional, can pass N\-U\-L\-L). \\
\hline
\mbox{\tt out}  & {\em Z} & The returned background value from the fit. \\
\hline
\mbox{\tt out}  & {\em A} & The returned amplitude value from the fit. \\
\hline
\mbox{\tt out}  & {\em tau} & The returned lifetime value from the fit. \\
\hline
\mbox{\tt out}  & {\em fitted} & An array containing values fitted to the data, the 'fit'. Fit points are coincident in time with the data points. \\
\hline
\mbox{\tt out}  & {\em residuals} & An array containing the difference between the data and the fit. \\
\hline
\mbox{\tt out}  & {\em chisq} & The resulting raw chi squared value of the fit. To get the reduced chisq, divide by the degrees of freedom (fit\-\_\-start -\/ fit\-\_\-end -\/ nparam) \\
\hline
\mbox{\tt in}  & {\em chisq\-\_\-target} & A raw chi squared value to aim for. If this value is reached fitting will stop. If you want to aim for a reduced chisq (say 1.\-1 or 1.\-0) you must multiply by the degree of freedom. (T\-R\-I2\-: \char`\"{}\-Try refits\char`\"{}) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
An error code, 0 = success. 
\end{DoxyReturn}


Definition at line 381 of file Ecf\-Single.\-c.

