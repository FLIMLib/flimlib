\hypertarget{_g_c_i___lsqnonneg_8c}{\section{G\-C\-I\-\_\-\-Lsqnonneg.\-c File Reference}
\label{_g_c_i___lsqnonneg_8c}\index{G\-C\-I\-\_\-\-Lsqnonneg.\-c@{G\-C\-I\-\_\-\-Lsqnonneg.\-c}}
}


S\-L\-I\-M Curve -\/ Non-\/negative Least Squares.  


{\ttfamily \#include $<$stdio.\-h$>$}\\*
{\ttfamily \#include $<$stdlib.\-h$>$}\\*
{\ttfamily \#include $<$string.\-h$>$}\\*
{\ttfamily \#include $<$math.\-h$>$}\\*
{\ttfamily \#include \char`\"{}G\-C\-I\-\_\-\-Lsqnonneg.\-h\char`\"{}}\\*
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{_g_c_i___lsqnonneg_8c_a5c707deff4e68c7283f2ed73665e0c77}{M\-A\-X\-\_\-\-V\-A\-R\-S}~50
\begin{DoxyCompactList}\small\item\em The greatest number of variables to be determined. \end{DoxyCompactList}\item 
\#define \hyperlink{_g_c_i___lsqnonneg_8c_a8be9be2628a7cde262d0ad7c4ebf9339}{M\-A\-X\-\_\-\-E\-Q\-N\-S}~10000
\begin{DoxyCompactList}\small\item\em The greatest number of equations to be used. \end{DoxyCompactList}\item 
\hypertarget{_g_c_i___lsqnonneg_8c_a6ebf6899d6c1c8b7b9d09be872c05aae}{\#define \hyperlink{_g_c_i___lsqnonneg_8c_a6ebf6899d6c1c8b7b9d09be872c05aae}{E\-P\-S}~1e-\/9}\label{_g_c_i___lsqnonneg_8c_a6ebf6899d6c1c8b7b9d09be872c05aae}

\begin{DoxyCompactList}\small\item\em Approximate machine epsilon. \end{DoxyCompactList}\item 
\hypertarget{_g_c_i___lsqnonneg_8c_a156b862ebf6d213f5da19b9e3ccb779e}{\#define \hyperlink{_g_c_i___lsqnonneg_8c_a156b862ebf6d213f5da19b9e3ccb779e}{T\-O\-L}~(100$\ast$\hyperlink{_g_c_i___lsqnonneg_8c_a6ebf6899d6c1c8b7b9d09be872c05aae}{E\-P\-S})}\label{_g_c_i___lsqnonneg_8c_a156b862ebf6d213f5da19b9e3ccb779e}

\begin{DoxyCompactList}\small\item\em Tolerance. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{_g_c_i___lsqnonneg_8c_a9dc0b48ff8ccb3ab5bfcd48e73fd1aa9}{Householder} (int mode, double $\ast$v, int p, int l, int m, double $\ast$u\-\_\-p, double $\ast$C\mbox{[}$\,$\mbox{]}, int n\-C)
\begin{DoxyCompactList}\small\item\em Function Householder. \end{DoxyCompactList}\item 
void \hyperlink{_g_c_i___lsqnonneg_8c_ae80324df1fc131ce0f8b87965b68af30}{Givens\-Calc} (double v\-\_\-1, double v\-\_\-2, double $\ast$c, double $\ast$s, double $\ast$r)
\begin{DoxyCompactList}\small\item\em Givens\-Calc. \end{DoxyCompactList}\item 
void \hyperlink{_g_c_i___lsqnonneg_8c_a26f057044890214807647841dfeddc11}{Givens\-Apply} (double c, double s, double $\ast$z\-\_\-1, double $\ast$z\-\_\-2)
\begin{DoxyCompactList}\small\item\em Givens\-Apply. \end{DoxyCompactList}\item 
int \hyperlink{_g_c_i___lsqnonneg_8c_aa4b6201eeb7a64bbb4070606e087503a}{G\-C\-I\-\_\-lsqnonneg} (double $\ast$$\ast$A\-\_\-orig, double $\ast$b\-\_\-orig, double $\ast$x, int m, int n, int preserve, double $\ast$rnorm\-\_\-orig, double $\ast$lambda)
\begin{DoxyCompactList}\small\item\em Function G\-C\-I\-\_\-lsqnonneg. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
S\-L\-I\-M Curve -\/ Non-\/negative Least Squares. Non-\/neg least squares library function

This code is based on code and descriptions in the book Lawson, C.\-L. and Hanson, R.\-J., Solving Least Squares Problems, Prentice-\/\-Hall, 1974

A brief description of the various algorithms used is included within this file, but for a full explanation, please refer to the above-\/mentioned book or a similar reference.

Julian Gilbey, Gray Cancer Institute, September 2002 

Definition in file \hyperlink{_g_c_i___lsqnonneg_8c_source}{G\-C\-I\-\_\-\-Lsqnonneg.\-c}.



\subsection{Macro Definition Documentation}
\hypertarget{_g_c_i___lsqnonneg_8c_a8be9be2628a7cde262d0ad7c4ebf9339}{\index{G\-C\-I\-\_\-\-Lsqnonneg.\-c@{G\-C\-I\-\_\-\-Lsqnonneg.\-c}!M\-A\-X\-\_\-\-E\-Q\-N\-S@{M\-A\-X\-\_\-\-E\-Q\-N\-S}}
\index{M\-A\-X\-\_\-\-E\-Q\-N\-S@{M\-A\-X\-\_\-\-E\-Q\-N\-S}!GCI_Lsqnonneg.c@{G\-C\-I\-\_\-\-Lsqnonneg.\-c}}
\subsubsection[{M\-A\-X\-\_\-\-E\-Q\-N\-S}]{\setlength{\rightskip}{0pt plus 5cm}\#define M\-A\-X\-\_\-\-E\-Q\-N\-S~10000}}\label{_g_c_i___lsqnonneg_8c_a8be9be2628a7cde262d0ad7c4ebf9339}


The greatest number of equations to be used. 

Again, this is to allocate an array in advance 

Definition at line 61 of file G\-C\-I\-\_\-\-Lsqnonneg.\-c.

\hypertarget{_g_c_i___lsqnonneg_8c_a5c707deff4e68c7283f2ed73665e0c77}{\index{G\-C\-I\-\_\-\-Lsqnonneg.\-c@{G\-C\-I\-\_\-\-Lsqnonneg.\-c}!M\-A\-X\-\_\-\-V\-A\-R\-S@{M\-A\-X\-\_\-\-V\-A\-R\-S}}
\index{M\-A\-X\-\_\-\-V\-A\-R\-S@{M\-A\-X\-\_\-\-V\-A\-R\-S}!GCI_Lsqnonneg.c@{G\-C\-I\-\_\-\-Lsqnonneg.\-c}}
\subsubsection[{M\-A\-X\-\_\-\-V\-A\-R\-S}]{\setlength{\rightskip}{0pt plus 5cm}\#define M\-A\-X\-\_\-\-V\-A\-R\-S~50}}\label{_g_c_i___lsqnonneg_8c_a5c707deff4e68c7283f2ed73665e0c77}


The greatest number of variables to be determined. 

This is to allocate an array in advance to save having to use malloc/free 

Definition at line 57 of file G\-C\-I\-\_\-\-Lsqnonneg.\-c.



\subsection{Function Documentation}
\hypertarget{_g_c_i___lsqnonneg_8c_aa4b6201eeb7a64bbb4070606e087503a}{\index{G\-C\-I\-\_\-\-Lsqnonneg.\-c@{G\-C\-I\-\_\-\-Lsqnonneg.\-c}!G\-C\-I\-\_\-lsqnonneg@{G\-C\-I\-\_\-lsqnonneg}}
\index{G\-C\-I\-\_\-lsqnonneg@{G\-C\-I\-\_\-lsqnonneg}!GCI_Lsqnonneg.c@{G\-C\-I\-\_\-\-Lsqnonneg.\-c}}
\subsubsection[{G\-C\-I\-\_\-lsqnonneg}]{\setlength{\rightskip}{0pt plus 5cm}int G\-C\-I\-\_\-lsqnonneg (
\begin{DoxyParamCaption}
\item[{double $\ast$$\ast$}]{A\-\_\-orig, }
\item[{double $\ast$}]{b\-\_\-orig, }
\item[{double $\ast$}]{x, }
\item[{int}]{m, }
\item[{int}]{n, }
\item[{int}]{preserve, }
\item[{double $\ast$}]{rnorm\-\_\-orig, }
\item[{double $\ast$}]{lambda}
\end{DoxyParamCaption}
)}}\label{_g_c_i___lsqnonneg_8c_aa4b6201eeb7a64bbb4070606e087503a}


Function G\-C\-I\-\_\-lsqnonneg. 

This function solves the non-\/negative least squares problem.

This function solves the non-\/negative least squares problem\-: minimise {\ttfamily $\vert$\-Ax-\/b$\vert$} subject to {\ttfamily x $>$= 0} (where $\vert$v$\vert$ is the 2-\/norm of the vector v).

The algorithm is similar to the simplex algorithm, and uses Lagrange multipliers.


\begin{DoxyEnumerate}
\item Set {\ttfamily P\-:=\{\}, Z\-:=\{1,2,...,n\}, x\-:=0}
\item Compute {\ttfamily w \-:= A$^\wedge$\-T (b-\/\-Ax)}
\item If {\ttfamily Z=\{\}} or {\ttfamily if w\-\_\-j $<$= 0} for all j in Z, stop
\item Find t in Z such that {\ttfamily w\-\_\-t = max \{ w\-\_\-j \-: j in Z \}}
\item Move index t from Z to P
\item Let A\-\_\-\-P denote the m x n matrix defined by \begin{DoxyVerb}       column j of A_P := ( column j of A   if j in P
                          ( 0               if j in Z
\end{DoxyVerb}


Compute the n-\/vector z as a solution of the regular least squares problem minimise {\ttfamily $\vert$ A\-\_\-\-P z -\/ b $\vert$}. Note that only the components z\-\_\-j, j in P, are determined by this problem. Define z\-\_\-j\-:=0 for j in Z.
\item If {\ttfamily z\-\_\-j$>$0} for all j in P, then set {\ttfamily x\-:=z} and goto step 2
\item Find an index q in P such that {\ttfamily x\-\_\-q/(x\-\_\-q-\/z\-\_\-q) = min \{ x\-\_\-j/(x\-\_\-j-\/z\-\_\-j) \-: z\-\_\-j $<$= 0, j in P \}}
\item Set {\ttfamily alpha \-:= x\-\_\-q/(x\-\_\-q-\/z\-\_\-q)}
\item Set {\ttfamily x \-:= x + alpha(z-\/x)}
\item Move from set P to set Z all j in P for which {\ttfamily x\-\_\-j=0}. Go to step 6.
\end{DoxyEnumerate}

On termination, x satisfies x\-\_\-j$>$0 for j in P and x\-\_\-j=0 for j in Z, and x is a solution to the least squares problem minimise $\vert$\-A\-\_\-\-P z -\/ b$\vert$.

Step 6 (finding the solution to the least squares problem {\ttfamily $\vert$\-A\-\_\-\-P z -\/ b$\vert$}) is performed using a Q\-R factorisation of A\-\_\-\-P, which in turn is calculated using Householder matrices and Givens rotations, and clever tricks for keeping track of the Q\-R factorisation of A\-\_\-\-P as P changes, as we describe below. 

Definition at line 360 of file G\-C\-I\-\_\-\-Lsqnonneg.\-c.

\hypertarget{_g_c_i___lsqnonneg_8c_a26f057044890214807647841dfeddc11}{\index{G\-C\-I\-\_\-\-Lsqnonneg.\-c@{G\-C\-I\-\_\-\-Lsqnonneg.\-c}!Givens\-Apply@{Givens\-Apply}}
\index{Givens\-Apply@{Givens\-Apply}!GCI_Lsqnonneg.c@{G\-C\-I\-\_\-\-Lsqnonneg.\-c}}
\subsubsection[{Givens\-Apply}]{\setlength{\rightskip}{0pt plus 5cm}void Givens\-Apply (
\begin{DoxyParamCaption}
\item[{double}]{c, }
\item[{double}]{s, }
\item[{double $\ast$}]{z\-\_\-1, }
\item[{double $\ast$}]{z\-\_\-2}
\end{DoxyParamCaption}
)}}\label{_g_c_i___lsqnonneg_8c_a26f057044890214807647841dfeddc11}


Givens\-Apply. 

The function Givens\-Apply applies a Givens rotation to a 2-\/vector. No rocket science there.

Here, then, are the algorithms we use\-:

Calculate a Givens rotation for the vector (v\-\_\-1 v\-\_\-2)$^\wedge$\-T (Givens\-Calc)\-:

Arguments\-: v\-\_\-1, v\-\_\-2, the input vector c, s, r, pointers to the answers. r may point to v\-\_\-1 or v\-\_\-2

1 if $\vert$v\-\_\-1$\vert$ $<$= $\vert$v\-\_\-2$\vert$ go to step 8 2 w \-:= v\-\_\-2/v\-\_\-1 3 q \-:= sqrt(1+w$^\wedge$2) 4 c \-:= 1/q 5 if v\-\_\-1 $<$ 0, c \-:= -\/c 6 s \-:= wc 7 r \-:= $\vert$v\-\_\-1$\vert$.q and stop 8 if v\-\_\-2 != 0, go to step 10 9 \mbox{[}v\-\_\-1=v\-\_\-2=0\mbox{]} c \-:= 1, s\-:= 0, r \-:= 0, stop 10 w \-:= v\-\_\-1/v\-\_\-2 11 q \-:= sqrt(1+w$^\wedge$2) 12 s \-:= 1/q 13 if v\-\_\-1 $<$ 0, s \-:= -\/s 14 c \-:= ws 15 r \-:= $\vert$v\-\_\-2$\vert$.q and stop

Apply the Givens rotation G to the vector (z\-\_\-1 z\-\_\-2)$^\wedge$\-T (Givens\-Apply)\-:

Arguments\-: c, s, components of the Givens rotation matrix z\-\_\-1, z\-\_\-2, (double $\ast$) the vector to apply it to; these will be overwritten!

1 w \-:= z\-\_\-1.\-c + z\-\_\-2.\-s 2 z\-\_\-2 \-:= -\/z\-\_\-1.\-s + z\-\_\-2.\-c 3 z\-\_\-1 \-:= w 

Definition at line 309 of file G\-C\-I\-\_\-\-Lsqnonneg.\-c.

\hypertarget{_g_c_i___lsqnonneg_8c_ae80324df1fc131ce0f8b87965b68af30}{\index{G\-C\-I\-\_\-\-Lsqnonneg.\-c@{G\-C\-I\-\_\-\-Lsqnonneg.\-c}!Givens\-Calc@{Givens\-Calc}}
\index{Givens\-Calc@{Givens\-Calc}!GCI_Lsqnonneg.c@{G\-C\-I\-\_\-\-Lsqnonneg.\-c}}
\subsubsection[{Givens\-Calc}]{\setlength{\rightskip}{0pt plus 5cm}void Givens\-Calc (
\begin{DoxyParamCaption}
\item[{double}]{v\-\_\-1, }
\item[{double}]{v\-\_\-2, }
\item[{double $\ast$}]{c, }
\item[{double $\ast$}]{s, }
\item[{double $\ast$}]{r}
\end{DoxyParamCaption}
)}}\label{_g_c_i___lsqnonneg_8c_ae80324df1fc131ce0f8b87965b68af30}


Givens\-Calc. 

The Givens\-Calc function takes as input a 2-\/vector, and computes the Givens rotation for this vector.

If the vector is v = (v\-\_\-1 v\-\_\-2)$^\wedge$\-T != 0, then the Givens rotation is the 2x2 (special) orthogonal matrix \begin{DoxyVerb}         G = (  c  s )
             ( -s  c )
\end{DoxyVerb}


(with c$^\wedge$2 + s$^\wedge$2 = 1) such that Gv = (r 0)$^\wedge$\-T, where r=$\vert$v$\vert$=sqrt(v\-\_\-1$^\wedge$2 + v\-\_\-2$^\wedge$2).

This function calculates c, s and r, avoiding overflow and underflow issues, and returns these values. (We can allow r to overwrite v\-\_\-1 or v\-\_\-2 if we wish.) The calculation is as follows\-:

To compute r=sqrt(x$^\wedge$2 + y$^\wedge$2)\-: t \-:= max \{$\vert$x$\vert$, $\vert$y$\vert$\} u \-:= min \{$\vert$x$\vert$, $\vert$y$\vert$\} r \-:= ( t.\-sqrt(1+(u/t)$^\wedge$2) if t != 0 ( 0 if t = 0 

Definition at line 241 of file G\-C\-I\-\_\-\-Lsqnonneg.\-c.

\hypertarget{_g_c_i___lsqnonneg_8c_a9dc0b48ff8ccb3ab5bfcd48e73fd1aa9}{\index{G\-C\-I\-\_\-\-Lsqnonneg.\-c@{G\-C\-I\-\_\-\-Lsqnonneg.\-c}!Householder@{Householder}}
\index{Householder@{Householder}!GCI_Lsqnonneg.c@{G\-C\-I\-\_\-\-Lsqnonneg.\-c}}
\subsubsection[{Householder}]{\setlength{\rightskip}{0pt plus 5cm}void Householder (
\begin{DoxyParamCaption}
\item[{int}]{mode, }
\item[{double $\ast$}]{v, }
\item[{int}]{p, }
\item[{int}]{l, }
\item[{int}]{m, }
\item[{double $\ast$}]{u\-\_\-p, }
\item[{double $\ast$}]{C\mbox{[}$\,$\mbox{]}, }
\item[{int}]{n\-C}
\end{DoxyParamCaption}
)}}\label{_g_c_i___lsqnonneg_8c_a9dc0b48ff8ccb3ab5bfcd48e73fd1aa9}


Function Householder. 

This function takes as input a vector, a pivot element and a zero point, and applies a Householder transformation to the vector to make all of its entries zero from the point specified, pivoting around the specified pivot entry, modifying the vector in the process, as described below. This function can also take a collection of other vectors and apply this Householder transformation to these vectors.

Here is a brief description of Householder transformations\-: we are looking for an orthogonal transformation Q with

Qv = ( v\-\_\-0 v\-\_\-1 ... v\-\_\-\{p-\/1\} -\/sigma.\-sqrt(v\-\_\-p$^\wedge$2+sum\-\_\-\{i=l\}$^\wedge$\{m-\/1\} v\-\_\-i$^\wedge$2) v\-\_\-\{p+1\} ... v\-\_\-\{l-\/1\} 0 ... 0)$^\wedge$\-T =\-: y

where sigma = +1 if v\-\_\-p $>$= 0 and -\/1 if v\-\_\-p $<$ 0.

Here p is the pivot index and l is the zeroing index, where we assume 0 $<$= p $<$= l $<$ m (where v is an m-\/vector, zero-\/based). If these assumptions are not true, we take Q=I.

Q is given by Q = I -\/ 2uu$^\wedge$\-T/$\vert$u$\vert$$^\wedge$2 for some vector u, but we do not actually need to calculate it. We do the following\-:

Compute\-: s \-:= -\/sigma.\-sqrt(v\-\_\-p$^\wedge$2+sum\-\_\-\{i=l\}$^\wedge$m v\-\_\-i$^\wedge$2) u\-\_\-i \-:= 0, i=0, ..., p-\/1 u\-\_\-p \-:= v\-\_\-p -\/ s u\-\_\-i \-:= 0, i=p+1, ..., l-\/1 u\-\_\-i \-:= v\-\_\-i, i=l, ..., m-\/1 b \-:= su\-\_\-p (so b = -\/$\vert$u$\vert$$^\wedge$2/2) Q \-:= ( I\-\_\-m + b$^\wedge$\{-\/1\}uu$^\wedge$\-T if b != 0 ( I\-\_\-m if b = 0

After this, we place the non-\/zero components of u and y into the storage previously occupied by v; we let v\-\_\-p \-:= y\-\_\-p and store u\-\_\-p separately.

To apply this transformation to the set of m-\/vectors c\-\_\-j, getting d\-\_\-j = Qc\-\_\-j, we do\-: \begin{DoxyVerb}     t_j := b^{-1}(u^T c_j)
     d_j := c_j + t_j u
\end{DoxyVerb}


if b != 0, and d\-\_\-j \-:= c\-\_\-j if b = 0.

This function computes u, b, y\-:=Qv and d\-\_\-j \-:= Qc\-\_\-j for all c\-\_\-j we are given. If u and y have already been computed, we can apply this Q to new c\-\_\-j vectors.

Arguments\-: mode\-: 1 means calculate u, b, y and then Qc\-\_\-j 2 means u and y are precalculated, just calculate Qc\-\_\-j v, the vector to pivot N\-B this vector is modified during execution of this function, as described above p, the pivot l, the zeroing point m, the length of the vector v u\-\_\-p (double $\ast$), the calculated value of u\-\_\-p C, double $\ast$$\ast$\-C, array of pointers to the c\-\_\-j vectors n\-C, number of c\-\_\-j vectors If C=N\-U\-L\-L or n\-C=0, the code will not attempt to find any Qc\-\_\-j. N\-B the calculated d\-\_\-j \-:= Qc\-\_\-j vectors will overwrite the C array

Here is the collected algorithm, as outlined above\-:

0 // Start here if mode = 1 1 s \-:= sqrt(v\-\_\-p$^\wedge$2 + sum\-\_\-\{i=l\}$^\wedge$\{m-\/1\} v\-\_\-i$^\wedge$2) (Use the calculation trick described below under Givens transformations to avoid calculation errors) 2 if v\-\_\-p $>$ 0, s \-:= -\/s 3 u\-\_\-p \-:= v\-\_\-p -\/ s, v\-\_\-p \-:= s 4 // Start here if mode = 2 5 b \-:= v\-\_\-p.\-u\-\_\-p 6 if b=0 or no C, stop 7 for each c\-\_\-j do steps 8-\/10 8 t\-\_\-j \-:= (c\-\_\-j\mbox{[}p\mbox{]}.u\-\_\-p + sum\-\_\-\{i=l\}$^\wedge$\{m-\/1\} c\-\_\-j\mbox{[}i\mbox{]}.v\-\_\-i) / b 9 c\-\_\-j\mbox{[}p\mbox{]} \-:= c\-\_\-j\mbox{[}p\mbox{]} + t\-\_\-j.\-u\-\_\-p 10 for i=l,...,m-\/1, c\-\_\-j\mbox{[}i\mbox{]} \-:= c\-\_\-j\mbox{[}i\mbox{]} + t\-\_\-j.\-v\-\_\-i 

Definition at line 159 of file G\-C\-I\-\_\-\-Lsqnonneg.\-c.

